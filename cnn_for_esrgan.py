# -*- coding: utf-8 -*-
"""CNN_for_ESRGAN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/120ZGtJJctkm9q4Umo_n32RACY50ux5nm

# **Part 1**
"""

from google.colab import drive
drive.mount('/content/drive')

from pathlib import Path
import os
import cv2
import os
import numpy as np
import pandas as pd
import torch
import torch.nn.functional as F
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix

"""解壓縮"""

!unzip '/content/drive/Shareddrives/ESRGAN_NTU/ESRGAN_CNN_original_data/train.zip' -d '/content/drive/Shareddrives/ESRGAN_NTU/ESRGAN_CNN_original_data/train'

"""CNN訓練與測試"""

import tensorflow
import os
import glob
import numpy as np
import cv2
import matplotlib.pyplot as plt
import pandas as pd
import itertools
from keras.preprocessing.image import ImageDataGenerator
from keras.applications.inception_v3 import InceptionV3
from keras.applications.vgg19 import VGG19
from tensorflow.keras.applications import EfficientNetB3
from keras.models import Model, Sequential, load_model
from keras import layers
from tensorflow.keras.optimizers import Adam, RMSprop, SGD, Adagrad
# from keras.optimizers import Adam, RMSprop
from keras.callbacks import EarlyStopping
from sklearn.metrics import confusion_matrix, roc_curve, auc

tensorflow.compat.v1.get_default_graph()

file_path = "/content/drive/Shareddrives/ESRGAN_NTU/ESRGAN_CNN_original_data" ###1

test_path = os.path.join(file_path, 'test')
train_path = os.path.join(file_path, 'train')
val_path = os.path.join(file_path, 'val')

# Pre-processing
labels = {0: "no", 1: "yes"}
def load_img(img_path):
  x = []
  y = []
  labels = os.listdir(img_path)
  for label in labels:
    for img_file in glob.glob(img_path + "/" + label + "/*.png"):
      img = cv2.imread(img_file)
      x.append(img)
      if label == "no":
        y.append(0)
      elif label == "yes":
        y.append(1)
  x = np.array(x)
  return x, y

val_x, val_y = load_img(val_path)
#train_x, train_y = load_img (train_path)

def preprocess(img_array, img_size = (300, 300)):
  new_x = []
  for img in img_array:
    new_img = cv2.resize(img, img_size, interpolation=cv2.INTER_AREA)
    # new_img = new_img/255
    new_x.append(new_img)
  new_x = np.array(new_x)
  return new_x

Max = np.max(val_x[0])
Min = np.min(val_x[0])
Mean = np.mean(val_x[0])
print("image_size : ", val_x[0].shape)
print("MAX : ", Max)
print("MIN : ", Min)
print("MEAN : ", Mean)

new_val_x = preprocess(val_x)
#new_train_x = preprocess(train_x)

N_Max = np.max(new_val_x[0])
N_Min = np.min(new_val_x[0])
N_Mean = np.mean(new_val_x[0])
print("image_size : ", new_val_x[0].shape)
print("MAX : ", N_Max)
print("MIN : ", N_Min)
print("MEAN : ", N_Mean)

"""# **Part 2**"""

# Data Augmentation
train_datagen  = ImageDataGenerator(horizontal_flip=False)

train_generator = train_datagen.flow_from_directory(train_path, target_size=(300, 300), batch_size=2, class_mode='binary')

val_datagen  = ImageDataGenerator(horizontal_flip=False)

val_generator = val_datagen.flow_from_directory(val_path, batch_size=2, target_size=(300, 300), class_mode='binary')

base_model = EfficientNetB3(
    include_top=False, weights="imagenet", input_tensor=None,
    input_shape=(300,300) + (3,), pooling=None, classes=1000)

NUM_CLASSES = 1

model = Sequential()
model.add(base_model)
model.add(layers.Flatten())
model.add(layers.Dropout(0.5))
model.add(layers.Dense(1, activation='sigmoid'))
model.layers[0].trainable = False

model.compile(loss='binary_crossentropy', optimizer=Adam(learning_rate=0.001,beta_1=0.9,beta_2=0.999, epsilon=1e-07,amsgrad=False,name="Adam"), metrics=['accuracy'])
model.summary()

EPOCHS = 200
history = model.fit(train_generator,
           epochs = EPOCHS,
           validation_data = val_generator)

model.save("/content/drive/Shareddrives/ESRGAN_NTU/ESRGAN_cnn_result/02_CNN_test_original/CNN_test.h5")###2

acc = history.history['accuracy']
loss = history.history['loss']
val_acc = history.history["val_accuracy"]
val_loss = history.history["val_loss"]
epochs_range = range(1, len(history.epoch) + 1)

plt.figure(figsize=(15,5))

plt.subplot(1, 2, 1)
plt.plot(epochs_range, acc, label='Train')
plt.plot(epochs_range, val_acc, label= "validation")
plt.legend(loc="best")
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.title('Model Accuracy')

plt.subplot(1, 2, 2)
plt.plot(epochs_range, loss, label='Train')
plt.plot(epochs_range, val_loss, label='validation')
plt.legend(loc="best")
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.title('Model Loss')

plt.tight_layout()
plt.savefig("/content/drive/Shareddrives/ESRGAN_NTU/ESRGAN_cnn_result/02_CNN_test_original/CMM_train_inv3.jpg")###3
plt.show()

model = load_model("/content/drive/Shareddrives/ESRGAN_NTU/ESRGAN_final_interal/ESRGAN_CNN_bestweight/02_CNN_test_original_best/CNN_test_best.h5")###4

def plot_confusion_matrix_train(cm, classes, normalize = False, title='Confusion matrix', cmap = plt.cm.Blues):
  plt.figure(figsize = (5,5))
  plt.imshow(cm, interpolation = 'nearest', cmap = cmap)
  plt.title(title)
  plt.colorbar()
  tick_marks = np.arange(len(classes))
  plt.xticks(tick_marks, classes, rotation = 90)
  plt.yticks(tick_marks, classes)
  if normalize:
    cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]

  thresh = cm.max()/2
  cm = np.round(cm, 2)
  for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
    plt.text(j, i, cm[i, j], horizontalalignment = "center", color = "white" if cm[i, j] > thresh else "black")
  # plt.tight_layout()
  plt.ylabel('True label')
  plt.xlabel('Predicted label')
  plt.tight_layout()
  plt.savefig("/content/drive/Shareddrives/ESRGAN_NTU/ESRGAN_cnn_result/01_CNN_test_original/train_confusion_matrix.jpg")###5
  plt.show()

train_x, train_y = load_img (train_path)
new_train_x = preprocess(train_x)

predictions = model.predict(new_train_x)
predictions = [1 if x > 0.5 else 0 for x in predictions]
# print("predictions : ", predictions)

confusion_mtx = confusion_matrix(train_y, predictions)
plot_confusion_matrix_train(confusion_mtx, classes = list(labels.items()), normalize=False)
#plt.savefig("/content/drive/Shareddrives/HCC_DATA/HCC_train_result/13_HCC_train_enfnet_0416/confusion_matrix.jpg")

fpr, tpr, _ = roc_curve(train_y, predictions)
area_under_curve = auc(fpr, tpr)

plt.plot(fpr, tpr, label = 'area = {:.3f}'.format(area_under_curve))
plt.xlabel('False Positive')
plt.ylabel('True Positive')
plt.title('ROC curve')
plt.legend(loc='best')
plt.savefig("/content/drive/Shareddrives/ESRGAN_NTU/ESRGAN_cnn_result/01_CNN_test_original/train_ROC.jpg")###6
plt.show()

"""# **Part 3**"""

test_path_split = "/content/drive/Shareddrives/ESRGAN_NTU/ESRGAN_final_interal/Clinical_data/new_clinical/new_original/new_original_all_01-018/original_au_YN_01-18"###7
test_x, test_y = load_img(test_path_split)
new_test_x = preprocess(test_x)
print(test_y)

def plot_confusion_matrix_test(cm, classes, normalize = False, title='Confusion matrix', cmap = plt.cm.Blues):
  plt.figure(figsize = (5,5))
  plt.imshow(cm, interpolation = 'nearest', cmap = cmap)
  plt.title(title)
  plt.colorbar()
  tick_marks = np.arange(len(classes))
  plt.xticks(tick_marks, classes, rotation = 90)
  plt.yticks(tick_marks, classes)
  if normalize:
    cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]

  thresh = cm.max()/2
  cm = np.round(cm, 2)
  for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
    plt.text(j, i, cm[i, j], horizontalalignment = "center", color = "white" if cm[i, j] > thresh else "black")
  # plt.tight_layout()
  plt.ylabel('True label')
  plt.xlabel('Predicted label')
  plt.tight_layout()
  plt.savefig("/content/drive/Shareddrives/ESRGAN_NTU/ESRGAN_final_interal/Clinical_data/new_clinical/new_original/new_original_all_01-018/CNN_result/original_confusion_matrix.jpg")###8
  plt.show()

predictions = model.predict(new_test_x)
predictions = [1 if x > 0.5 else 0 for x in predictions]
# print("predictions : ", predictions)

confusion_mtx = confusion_matrix(test_y, predictions)
#plt.savefig("/content/drive/Shareddrives/HCC_DATA/HCC_train_result/13_HCC_train_enfnet_0416/test_ROC.jpg")
plot_confusion_matrix_test(confusion_mtx, classes = list(labels.items()), normalize=False)

fpr, tpr, _ = roc_curve(test_y, predictions)
area_under_curve = auc(fpr, tpr)

plt.plot(fpr, tpr, label = 'area = {:.3f}'.format(area_under_curve))
plt.xlabel('False Positive')
plt.ylabel('True Positive')
plt.title('ROC curve')
plt.legend(loc='best')
plt.savefig("/content/drive/Shareddrives/ESRGAN_NTU/ESRGAN_final_interal/Clinical_data/new_clinical/new_original/new_original_all_01-018/CNN_result/original_ROC.jpg")###9
plt.show()

test_path = "/content/drive/Shareddrives/ESRGAN_NTU/ESRGAN_final_interal/Clinical_data/new_clinical/new_original/new_original_all_01-018/modify_deblur_ESRGAN_au_YN_01-18"###10
test_img = os.listdir(test_path)

test_img = os.listdir(test_path)
# test_img.sort(key = lambda x: int(x.split(".")[0]))

test = []
for img in test_img:
  image = cv2.imread(os.path.join(test_path, img))
  image = cv2.resize(image, (300, 300), interpolation=cv2.INTER_AREA)
  # image = image/255
  test.append(image)

test = np.array(test)

result = model.predict(test)
result = [1 if x > 0.5 else 0 for x in result]
print(result)

file_path_2 ="/content/drive/Shareddrives/ESRGAN_NTU/ESRGAN_final_interal/Clinical_data/new_clinical/CNN_new_clin_result"

df = pd.DataFrame({'case': test_img, 'predict': result})
df.to_csv(os.path.join(file_path_2,'modify_CNN_clin_original_AU_result.csv'), index = False)
